#!/usr/bin/env node
'use strict';
const update = require('../lib/update');  // version update check
const which = require('which');
const logger = require('../lib/out');
const app = require('commander');
const util = require('util');
const child = require('child_process');
const uuid = require('node-uuid');
const async = require('async');
const path = require('path');
const npa = require('npm-package-arg');
const fs = require('fs');
const fsx = require('fs-extra');
const tar = require('tar');
const fstream = require('fstream');
const zlib = require('zlib');

// Collect the command line arguments
var image, mod, test;
app
  .version('0.2.3')
  .description(
    'Generates a Docker image that can be used to run citgm for a ' +
    'specific module')
  .arguments('<image> <module> [test]')
  .action(function(i, m, t) {
    image = i;
    mod = m;
    test = t;
  })
  .option(
    '-t, --tag <tag>', 'Docker image tag'
  )
  .option(
    '-r, --run', 'Run the docker image immediately after build')
  .option(
    '-v, --verbose [level]', 'Verbose output',
    /^(info|warn|error)$/i, 'info')
  .option(
    '-k, --hmac <key>', 'HMAC Key for Script Verification')
  .option(
    '-l, --lookup <path>',
      'Use the lookup table provided at <path>'
  )
  .option(
      '-d, --nodedir',
      'Create the docker image with a /nodedir volume. \n' +
      '                The workding directory MUST contain a nodedir\n' +
      '                directory containing the node source image to use.\n' +
      '                This must be located in the working directory in\n' +
      '                or docker will refuse to copy it.'
  )
  .option(
      '-c, --citgmdir <path>',
      'By default, the docker image will install citgm from npm.\n' +
      '                Use this to tell the image to install from a host volume.'
  )
  .option(
    '-n, --no-color', 'Turns off colorized output'
  )
  .option(
    '-s, --su', 'Allow running the tool as root.'
  )
  .option(
    '-u, --uid <uid>', 'Set the uid (posix only)'
  )
  .option(
    '-g, --gid <uid>', 'Set the gid (posix only)'
  )
  .option(
    '-d, --docker <name>', 'Alternate docker binary name'
  );

app.parse(process.argv);

const log = logger({
  level:app.verbose,
  nocolor: !app.color
});
update(log);

const bin = app.docker || 'docker';

if (!image || !mod) {
  app.outputHelp();
  process.exit(0);
}

if (!app.su) {
  require('root-check')(); // silently downgrade if running as root...
                           // unless --su is passed
} else {
  log.warn('root', 'Running as root! Use caution!');
}

const tag = 'citgm-' + (app.tag || uuid.v4());

const detail = npa(mod);

// build the citgm CMD for the Dockerfile
function buildCmd(context, next) {
  var parts = ['citgm'];
  if (app.lookup) {
    parts.push('--lookup');
    if (context.lookup)
      parts.push('/usr/src/app/custom-lookup.json');
  }
  if (app.nodedir) {
    parts.push('--nodedir');
    parts.push('/nodedir');
  }
  if (app.su) {
    parts.push('--su');
  }
  if (app.verbose) {
    parts.push('--verbose');
    parts.push(app.verbose);
  }
  if (app.hmac) {
    parts.push('--hmac');
    parts.push('"' + app.hmac + '"');
  }
  if (!app.color) {
    parts.push('--no-color');
  }
  if (app.uid) {
    parts.push('--uid');
    parts.push(app.uid);
  }
  if (app.gid) {
    parts.push('--gid');
    parts.push(app.gid);
  }

  if (context.local) {
    parts.push('/usr/src/app/module.tar.gz');
  } else {
    parts.push(mod);
  }

  if (context.test)
    parts.push('/usr/src/app/custom-test');
  context.cmd = parts.join(' ');
  next(null,context);
}


// Optionally run's the docker image...
function runImage(context, next) {
  if (app.run) {
    var args = ['run'];
    log.info('docker-run', 'Running docker image: ' + context.tag);
    if (typeof app.nodedir === 'string') {
      var dir = path.resolve(process.cwd(),app.nodedir);
      log.info('nodedir', 'Using local nodedir: ' + dir);
      args.push('-v');
      args.push(util.format('"%s":/nodedir', dir));
    }
    args.push(context.tag);
    var proc = child.spawn(bin,
      [
        'run',
        context.tag
      ], {
        cwd: process.cwd(),
        stdio:[0,1,2]
      });
    proc.on('close', function(code) {
      log.info('docker-run', 'Finished running docker image');
      if (code > 0) {
        log.error('failed', util.format('Docker run failed [%d]', code));
      }
      next(null,context);
    });
  } else {
    next(null,context);
  }
}

function cleanLocal(context, next) {
  fs.unlinkSync('Dockerfile');
  if (context.local)
    fs.unlinkSync('module.tar.gz');
  if (context.test)
    fs.unlinkSync('custom-test');
  if (context.lookup)
    fs.unlinkSync('custom-lookup.json');
  if (app.citgmdir)
    fs.unlinkSync('citgm.tar.gz');
  next(null, context);
}

function buildImage(context, next) {
  var cwd = process.cwd();
  process.chdir(context.wd);
  var proc = child.spawn('docker',
    [
      'build',
      '--rm',
      '-t', context.tag,
      '.'
    ],
    {
      cwd: context.wd,
      stdio:[0,1,2]
    }
  );
  proc.on('error', function(err) {
    log.error('failure', err);
    next(err);
  })
  .on('close', function(code) {
    if (code > 0) {
      next(Error('Image not created'));
      return;
    }
    process.chdir(cwd);
    log.info('created', tag);
    next(null,context);
  });
}

function packCitgm(context, next) {
  function error(err) {
    log.error('pack-citgm', err);
    next(Error(util.format('Could not pack citgm')));
  }
  if (app.citgmdir) {
    var dest = path.join(context.wd, 'citgm.tar.gz');
    var src = path.resolve(process.cwd(), app.citgmdir);
    var file = fs.createWriteStream(dest)
      .on('error', error);
    var compressor = zlib.createGzip()
      .on('end', function() {
        file.close();
        log.info('pack-citgm', 'done');
        next(null,context);
      })
      .on('error', error);
    var packer = tar.Pack({noProprietary: true}).
      on('error', error);
    log.info('pack-citgm', 'packing ' + src);
    log.info('pack-citgm', 'dest ' + dest);
    fstream.Reader({path: src, type: 'Directory'}).
       on('error', error).
       pipe(packer).
       pipe(compressor).
       pipe(file);
  } else {
    next();
  }
}

function writeDockerfile(context, next) {
  var dest = fs.createWriteStream(path.join(context.wd, 'Dockerfile'), {encoding:'utf8'});
  dest.on('close', function() {
    packCitgm(context, function(err) {
      if (err) {
        next(err);
        return;
      }
      next(null, context);
    });
  });
  dest.on('error', function(err) {
    next(err);
  });
  var m = util.format('FROM %s\n',context.image);

  if (app.nodedir) {
    m += 'ADD nodedir /nodedir\n';
  }

  var args = ['-g'];
  if (app.nodedir) {
    args = ['--nodedir=/nodedir'].concat(args);
  }
  if (!app.citgmdir) {
    m += 'RUN npm install ' + args.join(' ') + ' citgm@latest\n';
  } else {
    m += 'COPY ["citgm.tar.gz","/usr/src/app/"]\n';
    m += 'RUN npm install ' + args.join(' ') + ' /usr/src/app/citgm.tar.gz\n';
  }

  if (context.local)
    m += 'COPY ["module.tar.gz","/usr/src/app/"]\n';
  if (context.test) {
    m += 'COPY ["custom-test","/usr/src/app/"]\n';
    //m += 'RUN chmod +x /usr/src/app/custom-test; sleep 2;\n';
  }
  if (context.lookup) {
    m += 'COPY ["custom-lookup.json", "/usr/src/app/"]\n';
  }
  m += 'CMD ' + context.cmd;
  dest.write(m);
  log.info('docker-file', m);
  dest.close();
}

function prepareCustomTest(context, next) {
  var test = context.test;
  if (test && !test.match(/^http(s)?:/i)) {
    fsx.copy(
      path.resolve(process.cwd(),test),
      path.join(context.wd,'custom-test'),
      function(err) {
        if (err) {
          next(err);
          return;
        }
        context.test = true;
        next(null,context);
      });
  } else {
    next(null, context);
  }
}

function prepareLookup(context, next) {
  if (typeof app.lookup === 'string') {
    fsx.copy(
      path.resolve(process.cwd(),app.lookup),
      path.join(context.wd,'custom-lookup.json'),
      function(err) {
        if (err) {
          next(err);
          return;
        }
        context.lookup = true;
        next(null,context);
      });
  } else {
    next(null, context);
  }
}

function packDirectory(raw, context, next) {
  function error() {
    next(Error(util.format('Could not pack module: ' ,path)));
  }
  var file = fs.createWriteStream(context.local)
    .on('error', error);
  var compressor = zlib.createGzip()
    .on('end', function() {
      file.close();
      next(null,context);
    })
    .on('error', error);
  var packer = tar.Pack({noProprietary: true}).
    on('error', error);
  fstream.Reader({path: raw, type: 'Directory'}).
     on('error', error).
     pipe(packer).
     pipe(compressor).
     pipe(file);
}

function prepareLocalModule(context, next) {
  if (detail.type === 'local') {
    context.local = path.join(context.wd,'module.tar.gz');
    var raw = path.resolve(process.cwd(), detail.raw);
    log.info('prepare-local-src', raw);
    log.info('prepare-local-dest', context.local);
    fs.lstat(raw, function(err,stat) {
      if (err) {
        next(Error(util.format('Cannot access local module: %s', raw)));
        return;
      }
      if (stat.isFile()) {
        log.info('prepare-local-copy','');
        fsx.copy(raw,context.local, function(err) {
          if (err) {
            next(err);
            return;
          }
          next(null,context);
        });
      } else if (stat.isDirectory()) {
        log.info('prepare-local-pack','');
        packDirectory(raw, context, next);
      } else {
        next(Error(util.format('Cannot access localmodule: %s', raw)));
        return;
      }
    });
  } else {
    next(null, context);
  }
}

function initContext(next) {
  next(null,{
    tag:tag,
    test:test,
    image:image
  });
}

function ensureDocker(context, next) {
  which(bin, function(err) {
    if (err) {
      log.error('failed', 'The docker client could not be found');
      next(Error('Aborting'));
      return;
    }
    next(null, context);
  });
}

function workingDirectory(context,next) {
  context.wd = process.cwd();
  next(null,context);
}

// launch the waterfall process...

async.waterfall([
  initContext,
  ensureDocker,
  workingDirectory,
  prepareLocalModule,
  prepareLookup,
  prepareCustomTest,
  buildCmd,
  writeDockerfile,
  buildImage,
  cleanLocal,
  runImage
], function(err, context) {
  if (err) {
    log.error('failed', err.message);
    process.exit(1);
  }
  log.info('done', context.tag);
});
